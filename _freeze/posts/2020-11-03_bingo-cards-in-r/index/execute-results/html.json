{
  "hash": "bd5349014e86851cd2449fcd28f597ee",
  "result": {
    "markdown": "---\ntitle: \"How to generate bingo cards in R\"\nsubtitle: |\n  A walkthrough the process of understanding how bingo cards are composed\n  and a set of R functions that let us generate random bingo cards and print them\n  in a nice looking .pdf output.\ndate: 2020-11-03\n---\n\n\nHello wor... Well, my first hello world post appeared about a year ago,\nbut this site had the same fate as many of my othe side-projects... abandonment.\n\nUntil now.\n\n## Introduction\n\nToday I'm going to show you how I came up with \"an algorithm\" to generate random\nbingo cards and some utility functions to print them on a nice looking (?) .pdf file.\n\nFirst of all, what type of bingo card I'm referring to? As an Argentine, the only\nbingo cards I've ever heard of are bingo cards like this one\n\n<center>\n\n![Example bingo card from bingo.es](imgs/bingo_card.png)\n\n</center>\n\nIt contains fifteen numbers from 1 to 90 that are divided in three rows and nine\ncolumns. The first column contains numbers between 1 and 9, the second column numbers\nbetween 10 and 20, and so on until the last column that contains numbers between\n80 and 90. The type of bingo that you play with this bingo card is known as the\n[90-ball bingo game](https://en.wikipedia.org/wiki/Bingo_(British_version))\nor British bingo. As I said, this is the only version I knew before this project\n^[How I dare to call this a project?] and I think it is the only bingo version you'll\nfind here in Argentina (I also bet you'll find some fellow Argentine confirming this\na national invention).\n\nSo, if you entered this post thinking you'll find how to print those bingo cards\nthat are popular in places like United States, I'm sorry, this is not for you\n^[But you should try this bingo, you gonna like it!].\nFortunately, other people have invented a tool for you even before I wondered\nhow to generate bingo cards. If you are interested, have a look at\n[this package](https://github.com/jennybc/bingo) and the Shiny app introduced there.\n\nNow, let's go back to our business.\n\nAnyone who has gone to one of those events where people gather to play bingo\n^[Some are also known as _sobremesa_] knows that bingo cards don't usually come\nseparated in individual pieces of paper. Sellers usually have strips of six bingo\ncards in their hands. In some events, you can buy bingo cards directly.\nIn others, you have to buy the entire strip.\n\nSince this is a 90-ball bingo game and each card contains fifteen numbers,\nsix bingo cards with no repeated numbers is all we need to have all the numbers of\nthe game in a single strip. You see where it is going?. Yes, we won't generate\nisolated cards, we'll generate entire strips. This is how a bingo strip looks like\n(just imagine them vertically stacked on a single strip)\n\n<center>\n\n![Example bingo strip from bingo.es](imgs/bingo_strip.PNG)\n\n</center>\n\n## Valid cards and valid strips\n\nBingo cards are not just a bunch of numbers thrown at a piece of paper.\nAll valid strips are composed of six valid cards each made of three valid rows.\nBut not any combinations of three valid rows make up a valid card nor any\ncombinations of six valid cards make up a valid strip. What a shame!\n\nBut what is a valid row, a valid card, a va... whatever.\nLet's just get to the point and list the rules that will govern how we generate\nbingo cards.\n\n### Valid row\n\nWe're going to think that a row is a numeric vector of length nine where some\nelements are empty and some are filled with numbers.\n\n* Exactly five elements are numbers, and four are empty.\n* There can't be more than two consecutive empty elements, which is equivalent to\nhaving at most three consecutive numbers.\n\n**Example valid rows**\n\n<center>\n\n![](imgs/valid_row_1.PNG)\n![](imgs/valid_row_2.PNG)\n\n</center>\n\n**Example invalid rows**\n\n<center>\n\n![](imgs/invalid_row_1.PNG)\n![](imgs/invalid_row_2.PNG)\n\n</center>\n\n\n### Valid card\n\nWe can think that a bingo card is a matrix of three rows and nine columns.\nEach row must be a valid row as specified in the previous point, plus\n\n* No column can be completely empty.\n* No column can be completely filled with numbers.\n* Numbers are sorted in ascending order within columns.\n\n**Example valid card**\n\n<center>\n\n![](imgs/valid_card_1.PNG)\n\n</center>\n\n### Valid strip\n\nA valid strip contains six valid cards that satisfy the following conditions\n\n* The first column must have **nine** numbers and nine empty slots.\n* Columns 2 to 8 must have **ten** numbers and eight empty slots.\n* Column 9 must have **eleven** numbers and seven empty slots.\n\nIn total, we have $6\\times3\\times9 = 162$ slots in a strip.\n90 of them are filled with numbers, 72 are not.\n\n## Sample this, sample that, I've got no need to compute them all^[Haven't you heard _Estallando desde el oc√©ano_ by Sumo?]\n\nOne approach to generate bingo cards would be to get all possible combinations\nof row layouts, bingo layouts, number arrangements, etc. But the [number\nof cards you could generate is huge](https://math.stackexchange.com/questions/510693/how-many-90-ball-bingo-cards-are-there)\nand the task wouldn't be easy at all.\n\nThe approach used here is one that mixes some simple combinatorics and random sampling.\nWe use permutations to compute all the possible row layouts. Then, we sample rows\nto create cards and sample cards to create strips^[If you've heard of Sampford's pps sampling, this is going to be familiar].\n\nFirst of all, we are going to find valid layouts (i.e. the skeleton of our bingo strips).\nOnce we have them, we are going to fill them with numbers.\n\n### Finding valid rows\n\nIf we represent empty slots with a 0 and filled slots with a 1, getting all\npermutations between four 0s and five 1s is as simple as calling\n`combinat::permn(c(rep(0, 4), rep(1, 5)))`. However, this is not what we want because\nnot all the returned layouts are valid rows. We need to select only those row layouts\nthat are valid in a bingo card.\n\nThe following function, `find_window()`, receives a numeric vector `x` and looks for\nfind windows of length `width` where all the elements are equal to `what`.\nIf such a window is found, the function returns `TRUE`, otherwise it returns `FALSE`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfind_window <- function(x, width, what) {\n    for (i in 1:(length(x) - width)) {\n        if (all(x[i:(i + width)] == what)) {\n            return(TRUE)\n        }\n    }\n    return(FALSE)\n}\n```\n:::\n\n\nThen we write a function called `get_rows()` that generates all the possible row\nlayouts and uses `find_window()` to select the layouts that satisfy our conditions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_rows <- function() {\n    # Get all row layouts\n    rows <- combinat::permn(c(rep(0, 4), rep(1, 5)))\n    # Keep rows with at most two consecutive empty slots\n    rows <- rows[!vapply(rows, find_window, logical(1), 2, 0)]\n    # Keep rows with at most three consecutive filled slots\n    rows <- rows[!vapply(rows, find_window, logical(1), 3, 1)]\n    return(rows)\n}\n```\n:::\n\n\n### Sampling valid cards\n\nWe noted that a valid card is made of three valid rows, but not all\ncombinations of three valid rows make up a valid card. What if we sample three row\nlayouts and keep/discard the combination based on whether they make up a\nvalid card or not? We can repeat this until we have some desired number\nof card layours. The process is as follows\n\n* Let $N$ be the number of cards we want to generate.\n* While the number of cards generated is smaller than $N$, do:\n  + Sample three rows and make up the card.\n  + Count the number of filled slots per column.\n  + If all the counts are between 1 and 3, keep the card, else discard it.\n\nOnce we're done, we end up with $N$ bingo card layouts that are valid in terms of\nour requirements above.\n\nThis idea is implemented in a function called `get_cards()`.\nIt receives the rows we generate with `get_rows()` and the number of card layouts we\nwant to generate. Finally it returns a list whose elements are vectors of length 3\nwith the row indexes^[I know that returning row indexes is less intuitive than\nreturning card layouts, but this approach requires less memory because it only\nstores 3 values per card, instead of 18.].\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_cards <- function(rows, cards_n = 2000) {\n    rows_n <- length(rows)\n    cards <- vector(\"list\", cards_n)\n\n    attempts <- 0\n    card_idx <- 0\n\n    while (card_idx < cards_n) {\n        attempts <- attempts + 1\n        # Sample three rows\n        row_idxs <- sample(rows_n, 3)\n        mm <- matrix(unlist(rows[row_idxs]), ncol = 9, byrow = TRUE)\n        col_sums <- colSums(mm)\n\n        # Select valid cards.\n        # These have between 1 and 3 numbers per column.\n        if (all(col_sums != 0) && all(col_sums != 3)) {\n            card_idx <- card_idx + 1\n            cards[[card_idx]] <- list(row_idxs, col_sums)\n        }\n        # Print message every 1000 attempts\n        if (attempts %% 1000 == 0) {\n            message(\"Attempt \", attempts, \" | Cards built:\", card_idx, \"\\n\")\n        }\n    }\n    # Check duplicates\n    dups <- duplicated(lapply(cards, `[[`, 1))\n    message(\"There are \", sum(dups), \" duplicated cards.\")\n    return(cards)\n}\n```\n:::\n\n\n### Sampling valid strips\n\nThis is the much like what we did above, with two differences.\nInstead of sampling three row layouts, we sample six card layouts.\nInstead of checking if the number of filled slots per column are between 1 and 3, we\ncheck if they match a number between 9 and 11 specific to each of them.\n\nThen, we have `get_strips()`. It receives a list called `cards` where each element\ncontains the three row indexes corresponding to each card layout.\n`rows` is a list of row layouts and `strips_n` controls how many strip layouts\nwe want to generate.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_strips <- function(cards, rows, strips_n = 100) {\n    valid_counts <- c(9, rep(10, 7), 11)\n    cards_n <- length(cards)\n    strips <- vector(\"list\", strips_n)\n\n    attempts <- 0\n    strip_idx <- 0\n\n    while (strip_idx < strips_n) {\n        attempts <- attempts + 1\n\n        # Sample 6 cards\n        cards_idxs <- sample(cards_n, 6)\n        strip <- cards[cards_idxs]\n\n        # Contains column counts by card\n        card_counts <- matrix(\n            unlist(lapply(strip, `[[`, 2)),\n            ncol = 9, byrow = TRUE\n        )\n\n        # Check if strip column counts are valid\n        if (all(colSums(card_counts) == valid_counts)) {\n            strip_idx <- strip_idx + 1\n            # Get row indexes contained in the selected card indexes\n            rows_idxs <- unlist(lapply(cards[cards_idxs], `[[`, 1))\n            strips[[strip_idx]] <- matrix(\n                unlist(rows[rows_idxs]),\n                ncol = 9, byrow = TRUE\n            )\n        }\n        # Print message every 1000 attempts\n        if (attempts %% 1000 == 0) {\n            message(\"Attempt \", attempts, \" | Strips built:\", strip_idx, \"\\n\")\n        }\n    }\n    dups <- duplicated(strips)\n    message(\"There are \", sum(dups), \" duplicatd layouts.\\n\")\n    return(strips)\n}\n```\n:::\n\n\n### A last but not least step\n\nI've never seen a bingo game where you are given empty layouts and are asked\nto put numbers yourself. So let's wrap this up and fill our empty cards!\n\n`fill_strips()` receives the strip layouts we generated, randomly selects `n` of them,\nand, also randomly, fills the slots the cards with numbers.\nOf course, the first column contains numbers from 1 to 9, the second column contains\nnumbers from 10 to 19... and so on until the last column, that has numbers\nfrom 80 to 90.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfill_strips <- function(strips, n = 100) {\n    # Numbers that go in each column\n    numbers <- list(1:9, 10:19, 20:29, 30:39, 40:49, 50:59, 60:69, 70:79, 80:90)\n    # Row indexes corresponding to each card in the strip\n    card_rows <- list(1:3, 4:6, 7:9, 10:12, 13:15, 16:18)\n\n    fill_strip <- function(strip) {\n        # Put numbers in the slots with a 1 (meaning they must contain a number)\n        strip[strip == 1] <- unlist(\n            # This `sample()` reorders the numbers in each column randomly\n            mapply(sample, numbers, sapply(numbers, length))\n        )\n\n        for (i in seq_along(card_rows)) {\n            strip_ <- strip[card_rows[[i]], ]\n            # Numbers in a given column are sorted in ascending order within cards\n            x <- sort(strip_)\n            strip_[strip_ != 0] <- x[x != 0]\n            strip[card_rows[[i]], ] <- strip_\n        }\n        return(strip)\n    }\n    # Strip layouts can be repeated\n    strips <- lapply(sample(strips, n, replace = TRUE), fill_strip)\n    message(\"There are \", sum(duplicated(strips)), \" duplicated strips.\\n\")\n    return(strips)\n}\n```\n:::\n\n\nAnd we finally get our bingo strips :)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(0303456)\nrows <- get_rows()\ncards <- get_cards(rows, 1000)\nstrips <- get_strips(cards, rows, 20)\nstrips <- fill_strips(strips, 50)\n# Output messages have been suppressed\n```\n:::\n\n\nLet's check some of them\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstrips[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\n [1,]    0   11   20    0   48    0    0   74   80\n [2,]    8    0    0   31    0   51   60   78    0\n [3,]    0   19   27   39    0   54   62    0    0\n [4,]    1    0   26    0   42   55    0    0   84\n [5,]    2   14    0   34    0    0   65   77    0\n [6,]    0   17   29    0   43   59    0    0   89\n [7,]    0    0   22   33    0    0   64   75   88\n [8,]    0   15    0   35   45    0    0   79   90\n [9,]    9    0   25    0   49   50   66    0    0\n[10,]    3    0   28   30    0    0   61   71    0\n[11,]    7    0    0   36   40   58    0    0   81\n[12,]    0   10    0    0   44    0   63   76   87\n[13,]    0    0   21   37    0   52   68   70    0\n[14,]    5   16    0    0   41    0    0   72   82\n[15,]    0   18    0   38   47   57    0    0   86\n[16,]    0    0   23    0   46   53    0   73   83\n[17,]    4   12    0   32    0    0   67    0   85\n[18,]    6   13   24    0    0   56   69    0    0\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstrips[[30]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\n [1,]    0    0   25    0   43   50    0   74   80\n [2,]    0   16   26   34    0    0   65   79    0\n [3,]    6   17    0   38    0   58    0    0   86\n [4,]    3    0   27    0   40   51   61    0    0\n [5,]    4    0    0   32   49   59    0    0   81\n [6,]    0   19   29   35    0    0   68   71    0\n [7,]    1   14    0    0   47    0   60   75    0\n [8,]    2    0   20   31    0    0   66    0   83\n [9,]    0    0   24    0   48   55    0   77   89\n[10,]    0    0   28   33   42    0   64   76    0\n[11,]    5   12    0   39    0    0   67    0   84\n[12,]    9   15    0    0   45   54    0    0   87\n[13,]    0   13   21    0    0   52    0   73   85\n[14,]    0   18   22    0   44    0   63   78    0\n[15,]    8    0    0   37   46   56    0    0   90\n[16,]    0    0   23   30    0   53   62    0   82\n[17,]    7   10    0   36    0    0   69   70    0\n[18,]    0   11    0    0   41   57    0   72   88\n```\n:::\n:::\n\n\n## Are we going to play on R consoles?\n\nAll we got so far are matrices that _look like_ a bingo strip. But honestly,\nwithout any given context, they just look like a bunch of matrices of the same dimension\nfilled with 0s and other integer numbers. Our last task is to generate a .pdf output\nwhere these matrices really look like bingo cards.\n\nIn this last part of the post we make use of the `grid` package. For those who\nhaven't heard of it, it is the low level plotting library behind `ggplot2`, for example.\n\nHere we have a little function, `make_grid()`, that given a number of rows and\ncolumns returns the _natural parent coordinates_ of the borders the grid that defines\nthe rectangles within each card.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_grid <- function(rows, cols) {\n    lines_rows <- grid::unit((0:rows) / rows, \"npc\")\n    lines_cols <- grid::unit((0:cols) / cols, \"npc\")\n    return(list(\"row\" = lines_rows, \"col\" = lines_cols))\n}\n```\n:::\n\n\nAnd now we have the main function used to plot the bingo strips. Since the function\nis quite large, I prefer to explain how it works with comments in the body.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_strips <- function(strips, col = \"#8e44ad\", width_row = 0.925,\n                        width_col = 0.975) {\n\n    # `rows` and `cols` are the dimensions of each card\n    rows <- 3\n    cols <- 9\n    g <- make_grid(rows, cols)\n    # Compute the center of each square in the card grid\n    centers_rows <- g$row[-1] - grid::unit(1 / (rows * 2), \"npc\")\n    centers_cols <- g$col[-1] - grid::unit(1 / (cols * 2), \"npc\")\n    # Sort the centers appropiately\n    # This is required because of how we loop over the values in each card\n    x_coords <- rep(centers_cols, each = rows)\n    y_coords <- rep(rev(centers_rows), cols)\n\n    # Create unique identifiers for the cards\n    cards_n <- paste(\n        paste0(\"CARD N\", intToUtf8(176)),\n        seq_len(length(strips) * 6)\n    )\n    # Compute the number of sheets we're going to need.\n    # Each sheet contains two strips\n    sheets_n <- ceiling(length(strips) / 2)\n\n    # Initial numbers\n    card_idx <- 0\n    strip_idx <- 0\n\n    # Loop over sheets\n    for (sheet_idx in seq_len(sheets_n)) {\n        # Each sheet is a grid of 6 rows and 3 columns.\n        # Columns 1 and 3 are where we place the strips.\n        # Column 2 just gives vertical separation.\n        l <- grid::grid.layout(\n            nrow = 6, ncol = 3,\n            widths = c(48.75, 2.5 + 3.75, 48.75)\n        )\n        # Start a new page filled with white\n        grid::grid.newpage()\n        grid::grid.rect(gp = grid::gpar(col = NULL, fill = \"white\"))\n\n        vp_mid <- grid::viewport(0.5, 0.5, width_row, width_col, layout = l)\n        grid::pushViewport(vp_mid)\n\n        # Loop over columns 1 and 3\n        for (j in c(1, 3)) {\n            # Select strip\n            strip_idx <- strip_idx + 1\n            if (strip_idx > length(strips)) break\n            strip <- strips[[strip_idx]]\n\n            # Loop over rows (these rows represent the 6 rows assigned to cards)\n            for (i in 1L:l$nrow) {\n                card_idx <- card_idx + 1\n                vp_inner <- grid::viewport(layout.pos.row = i, layout.pos.col = j)\n                grid::pushViewport(vp_inner)\n\n                # Add card identification number on top-left\n                grid::grid.text(\n                    label = cards_n[card_idx],\n                    x = 0,\n                    y = 0.96,\n                    just = \"left\",\n                    gp = grid::gpar(fontsize = 9)\n                )\n\n                # Draw a grill that separates the slots in the card\n                vp_mid_inner <- grid::viewport(0.5, 0.5, 1, 0.80)\n                grid::pushViewport(vp_mid_inner)\n                grid::grid.grill(h = g$row, v = g$col, gp = grid::gpar(col = col))\n\n                # Select the numbers that correspond to this card\n                numbers <- as.vector(strip[(3 * i - 2):(3 * i), ])\n                # Logical vector that indicates which rectangles are filled\n                # with nunumbers and which rectangles are empty\n                lgl <- ifelse(numbers == 0, FALSE, TRUE)\n\n                # Draw the numbers in positions given by the rectangle centers\n                grid::grid.text(\n                    label = numbers[lgl],\n                    x = x_coords[lgl],\n                    y = y_coords[lgl],\n                    gp = grid::gpar(fontsize = 18)\n                )\n\n                # Fill empty slots with color\n                grid::grid.rect(\n                    x = x_coords[!lgl],\n                    y = y_coords[!lgl],\n                    height = grid::unit(1 / rows, \"npc\"),\n                    width = grid::unit(1 / cols, \"npc\"),\n                    gp = grid::gpar(\n                        col = NA,\n                        fill = farver::encode_colour(farver::decode_colour(col), 0.7)\n                    )\n                )\n                # End\n                grid::popViewport()\n                grid::popViewport()\n            }\n        }\n        grid::popViewport()\n    }\n}\n```\n:::\n\n\nNow, all we need is to pass the `strips` generated above to `plot_strips()` and\nwrap that call within `grDevices::pdf()` and `grDevices::dev.off()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Height and width are in inches and here they correspond to legal paper size\ngrDevices::pdf(\"imgs/strips.pdf\", height = 14, width = 8.5)\nplot_strips(strips)\ngrDevices::dev.off()\n```\n:::\n\n\nIf it works, you'll have a 25 pages pdf with bingo cards that look like this one\n\n<center>\n\n![First card in the output](imgs/bingo_card_own.PNG)\n\n</center>\n\nIf you can't (or just don't want to) run the code,\n[here](imgs/strips.pdf) you have the generated\npdf.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}