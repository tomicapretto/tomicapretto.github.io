{
  "hash": "54bf273dd3cdcd54b4cdb0fcb4d35c70",
  "result": {
    "markdown": "---\ntitle: \"Design matrices for group-specific effects in formulae and lme4\"\nsubtitle: |\n  Bambi uses the library formulae to automatically construct design\n  matrices for both common and group-specific effects. This post compares design\n  matrices for group-specific effects obtained with formulae for a variety of\n  scenarios involving categorical variables with the ones obtained with the R\n  package lme4.\ndate: 2021-06-08\n---\n\n\n## Introduction\n\nA linear mixed model can be written as\n\n\n$$\n\\boldsymbol{y} = \\boldsymbol{X}\\boldsymbol{\\beta} +\n                 \\boldsymbol{Z}\\boldsymbol{u} + \\boldsymbol{\\epsilon}\n$$\n\n\nwhere $\\boldsymbol{X}$ and $\\boldsymbol{Z}$ are the two design matrices we need\nto somehow construct when dealing with this type of model. $\\boldsymbol{X}$ is\nthe design matrix for the common (a.k.a. fixed) effects, and $\\boldsymbol{Z}$ is the design\nmatrix for the group-specific (a.k.a. random or varying) effects.\n\nIt is quite easy to obtain the design matrix $\\boldsymbol{X}$ in R using its\npopular formula interface. In Python, [patsy](https://patsy.readthedocs.io/)\nprovides equivalent functionality. Unfortunately, there aren't as many\nalternatives to compute the matrix $\\boldsymbol{Z}$.\n\nIn R, there's [lme4](https://CRAN.R-project.org/package=lme4), the statistical\npackage par excellence for mixed models. It extends the base formula interface\nto include group-specific effects via the pipe operator (`|`) and internally\ncomputes both $\\boldsymbol{X}$ and $\\boldsymbol{Z}$ without the user noticing.\nThat's great!\n\nIn Python, we are working on [formulae](https://bambinos.github.io/formulae/),\na library we use to handle mixed model formulas in [Bambi](https://bambinos.github.io/bambi).\nIn this process, I've found [Fitting Linear Mixed-Effects Models Using lme4](https://cran.r-project.org/web/packages/lme4/vignettes/lmer.pdf)\nvignette extremely useful when figuring out how to compute the design matrix\nfor the group-specific effects.\n\nToday, I was adding tests to make sure we are constructing $\\boldsymbol{Z}$\nappropriately and found myself comparing the matrices obtained with formulae with matrices\nobtained with **lme4**. Then I was like ... why not making this a blog post?\nðŸ¤”\n\nâ€¦ and so here we are! But before we get started, just note this post mixes both\nR and Python code. I will try to be explicit when I'm using one language or the\nother. But if you're reading a chunk and it looks like Python, it's Python. And\nif it looks like R... you guessed! It's R.\n\n## Setup\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(lme4)\nlibrary(patchwork)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\nfrom formulae import design_matrices\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n## Problem\n\nHere we will be comparing design matrices for the group-specific terms in\na mixed-effects model obtained with both **lme4** and **formulae**. We're using\nthe dataset `Pixel` that comes with the R package **nlme**.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata(\"Pixel\", package = \"nlme\")\nhead(Pixel)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGrouped Data: pixel ~ day | Dog/Side\n  Dog Side day  pixel\n1   1    R   0 1045.8\n2   1    R   1 1044.5\n3   1    R   2 1042.9\n4   1    R   4 1050.4\n5   1    R   6 1045.2\n6   1    R  10 1038.9\n```\n:::\n:::\n\n\nWe're not interested in how to fit a certain model here. We're interested in\nconstructing the design matrix for group-specific effects with different\ncharacteristics. We use the following formula\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nf1 = ~ (0 + day | Dog) + (1 | Side / Dog)\n```\n:::\n\n\nwhere each part can be interpreted as follows\n\n* `(0 + day | Dog)` means that `day` has a group-specific slope for each `Dog`.\nThis is usually known as a random slope. The `0` indicates not to add the default\ngroup-specific intercept (because it's added next).\n* `(1 | Side / Dog)` is equivalent to `(1 | Side) + (1 | Dog:Side)`. This means\nthere's a varying intercept for each `Side` and a varying intercept for each\ncombination of `Dog` and `Side`. In other words, we have a nested group-specific\nintercept, where `Dog` is nested within `Side`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlme4_terms = mkReTrms(findbars(f1), model.frame(subbars(f1), data = Pixel))\n```\n:::\n\n\n`lme4_terms` contains much more information than what we need for this post.\nWe mostly use `lme4_terms$Ztlist`, which is a list that contains the transpose of\nthe group-specific effects model matrix, separated by term.\nThese matrices are stored as sparse matrices of `dgCMatrix` class. If we\nwant to have the sub-matrix for a given group-specific term as a base R matrix,\nwe have to do `as.matrix(t(lme4_terms$Ztlist$[[\"term\"]]))`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnames(lme4_terms$Ztlist)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1 | Dog:Side\"  \"0 + day | Dog\" \"1 | Side\"     \n```\n:::\n:::\n\n\nWe have three group-specific terms. The first and the last ones are the group-specific\nintercepts we mentioned. These are the result of the nested group-specific\nintercept `(1 | Side / Dog)`. `Dog` is nested within `Side` and consequently\nthere's an intercept varying among `Side` and another varying among `Dog` within\n`Side`. The second term, `0 + day | Dog`, represents varying slope of `day` for\neach level of `Dog`.\n\nWe finally store the sub-matrix for each term in different objects that we'll\nlater use when comparing results with those obtained with **formulae**.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nday_by_dog = as.matrix(t(lme4_terms$Ztlist$`0 + day | Dog`))\nintercept_by_side = as.matrix(t(lme4_terms$Ztlist$`1 | Side`))\nintercept_by_side_dog = as.matrix(t(lme4_terms$Ztlist$`1 | Dog:Side`))\n```\n:::\n\n\nOn the other hand, in Python, we use `design_matrices()` from the **formulae**\nlibrary to obtain a `DesignMatrices` object. All the information associated with\nthe group-specific terms is contained in the `.group` attribute and the\nsub-matrix corresponding to a particular term is accessed with `.group[term_name]`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\ndm = design_matrices(\"(0 + day | Dog) + (1 | Side / Dog)\", r.Pixel)\n```\n:::\n\n\nThere's a dictionary called `terms_info` within `dm.group`. To see the names\nof the group-specific effects we just retrieve the keys.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\ndm.group.terms.keys()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndict_keys(['day|Dog', '1|Side', '1|Side:Dog'])\n```\n:::\n:::\n\n\nNames differ a little with the ones from **lme4**, but they represent the same\nthing.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\nday_by_dog = dm.group['day|Dog']\nintercept_by_side = dm.group['1|Side']\nintercept_by_side_dog = dm.group['1|Side:Dog']\n```\n:::\n\n\nNow let's compare those matrices!\n\n## Design matrices for `(day|Dog)`\n\nRectangles in the following plot correspond to the cells in the matrix. The lowest\nvalue for `day` is 0, represented by violet, and the highest value is 21,\nrepresented by yellow. The 10 columns represent the 10 groups in `Dog`, and the\nrows represent the observations in `Pixel`. Here, and also in the other cases,\nthe left panel contains the matrix obtained with **lme4** and the right panel the\none produced with **formulae**.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){fig-align='center' width=95%}\n:::\n:::\n\n\nIn this first case, both panels are representing the same data so we can happily\nconclude the result obtained with **formulae** matches the one from **lme4**. Yay!!\n\nBut we're humans and our eyes can fail so it's better to always check\nappropiately with\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nall(py$day_by_dog == day_by_dog)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n### Design matrices for `(1|Side)`\n\nHere the first column represents `Side == \"L\"` and the second column represents\n`Side == \"R\"`. Since we're dealing with an intercept, violet means 0 and yellow\nmeans 1. In this case it is much easier to see both results match.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){fig-align='center' width=95%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nall(py$intercept_by_side == intercept_by_side)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n### Design matrices for `(1|Side:Dog)`\n\nBut things are not always as one wishes. It's clear from the following plot\nthat both matrices aren't equal here.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){fig-align='center' width=95%}\n:::\n:::\n\n\nBut don't worry. We're not giving up. We still have things to do^[I was undoubtedly\ntalking to myself was quite disappointed at this time, wondering what I did wrong.\nSuffering the consequences of mistakes I wasn't even aware I made. Well, not\nthat dramatic. But now I'm happy the problem wasn't real ðŸ˜…].\nWe can check what are the groups being represented in the columns of the matrices\nwe're plotting.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncolnames(intercept_by_side_dog)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"1:L\"  \"1:R\"  \"10:L\" \"10:R\" \"2:L\"  \"2:R\"  \"3:L\"  \"3:R\"  \"4:L\"  \"4:R\" \n[11] \"5:L\"  \"5:R\"  \"6:L\"  \"6:R\"  \"7:L\"  \"7:R\"  \"8:L\"  \"8:R\"  \"9:L\"  \"9:R\" \n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\ndm.group.terms[\"1|Side:Dog\"].labels\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['1|Side[L]:Dog[1]', '1|Side[L]:Dog[10]', '1|Side[L]:Dog[2]', '1|Side[L]:Dog[3]', '1|Side[L]:Dog[4]', '1|Side[L]:Dog[5]', '1|Side[L]:Dog[6]', '1|Side[L]:Dog[7]', '1|Side[L]:Dog[8]', '1|Side[L]:Dog[9]', '1|Side[R]:Dog[1]', '1|Side[R]:Dog[10]', '1|Side[R]:Dog[2]', '1|Side[R]:Dog[3]', '1|Side[R]:Dog[4]', '1|Side[R]:Dog[5]', '1|Side[R]:Dog[6]', '1|Side[R]:Dog[7]', '1|Side[R]:Dog[8]', '1|Side[R]:Dog[9]']\n```\n:::\n:::\n\n\nAnd there it is! Matrices differ because columns are representing different\ngroups. In **lme4**, groups are looping first along `Dog` and then along `Side`,\nwhile in **formulae** it is the other way around.\n\nWe can simply re-order the columns of one of the matrices and generate\nand check whether they match or not.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nintercept_by_side_dog_f = as.data.frame(py$intercept_by_side_dog)\ncolnames(intercept_by_side_dog_f) = py$dm$group$terms[[\"1|Side:Dog\"]]$groups\nnames_lme4_order = paste(\n  rep(c(\"L\", \"R\"), 10),\n  rep(c(1, 10, 2, 3, 4, 5, 6, 7, 8, 9), each = 2),\n  sep = \":\"\n)\nintercept_by_side_dog_f = intercept_by_side_dog_f[names_lme4_order] %>%\n  as.matrix() %>%\n  unname()\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){fig-align='center' width=95%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nall(intercept_by_side_dog_f == intercept_by_side_dog)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nAnd there it is! Results match ðŸ¤©\n\n## Another formula\n\nThis other formula contains an interaction between categorical variables as the\nexpression of the group-specific term, which is something we're not covering\nabove. In this case, we are going to subset the data so the design matrices are\nsmaller and we can understand what's going on with more ease.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Subset data\nPixel2 = Pixel %>%\n  filter(Dog %in% c(1, 2, 3), day %in% c(2, 4, 6)) %>%\n  mutate(Dog = forcats::fct_drop(Dog))\n# Create terms with lme4\nf2 = ~ day +  (0 + Dog:Side | day)\nlme4_terms = mkReTrms(findbars(f2), model.frame(subbars(f2), data = Pixel2))\ndog_and_side_by_day = as.matrix(t(lme4_terms$Ztlist$`0 + Dog:Side | day`))\n```\n:::\n\n\nAnd now with `design_matrices()` in Python.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\n# Create terms with\ndm = design_matrices(\"(0 + Dog:Side|day)\", r.Pixel2)\ndog_and_side_by_day = dm.group[\"Dog:Side|day\"]\n```\n:::\n\n\n### Design matrix for `(Dog:Side|day)`\n\nAlthough this term is called slope, it is not actually a slope like the one\nfor `(day|Dog)`. Since both `Dog` and `Side` are categorical, the entries\nof this matrix consist of zeros and ones.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-22-1.png){fig-align='center' width=95%}\n:::\n:::\n\n\nWe have the same problem than above, matrices don't match. So we know what\nto do: look at the groups represented in the columns.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncolnames(dog_and_side_by_day)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \"4\" \"4\" \"4\" \"4\" \"4\" \"4\" \"6\" \"6\" \"6\" \"6\" \"6\" \"6\"\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\ndm.group.terms[\"Dog:Side|day\"].labels\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['Dog[1]:Side[L]|day[2.0]', 'Dog[1]:Side[R]|day[2.0]', 'Dog[2]:Side[L]|day[2.0]', 'Dog[2]:Side[R]|day[2.0]', 'Dog[3]:Side[L]|day[2.0]', 'Dog[3]:Side[R]|day[2.0]', 'Dog[1]:Side[L]|day[4.0]', 'Dog[1]:Side[R]|day[4.0]', 'Dog[2]:Side[L]|day[4.0]', 'Dog[2]:Side[R]|day[4.0]', 'Dog[3]:Side[L]|day[4.0]', 'Dog[3]:Side[R]|day[4.0]', 'Dog[1]:Side[L]|day[6.0]', 'Dog[1]:Side[R]|day[6.0]', 'Dog[2]:Side[L]|day[6.0]', 'Dog[2]:Side[R]|day[6.0]', 'Dog[3]:Side[L]|day[6.0]', 'Dog[3]:Side[R]|day[6.0]']\n```\n:::\n:::\n\n\nBut this they represent the same groups^[We have six 2s, six 4s and six 6s in both cases].\nWe can look if there's a difference in how the interactions are ordered within\neach group.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlme4_terms$cnms\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$day\n[1] \"Dog1:SideL\" \"Dog2:SideL\" \"Dog3:SideL\" \"Dog1:SideR\" \"Dog2:SideR\"\n[6] \"Dog3:SideR\"\n```\n:::\n:::\n\n\nAnd again, thankfully, we see there's a difference in how columns are being ordered.\nLet's see if matrices match after we reorder the one obtained with **formulae**.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndog_and_side_by_day_f = as.data.frame(py$dog_and_side_by_day)\ncolnames(dog_and_side_by_day_f) = py$dm$group$terms[[\"Dog:Side|day\"]]$labels\nside = rep(rep(c(\"L\", \"R\"), each = 3), 3)\ndog = rep(1:3, 6)\nday = rep(c(\"2.0\", \"4.0\", \"6.0\"), each = 6)\nnames_lme4_order = glue::glue(\"Dog[{dog}]:Side[{side}]|day[{day}]\")\ndog_and_side_by_day_f = dog_and_side_by_day_f[names_lme4_order] %>%\n  as.matrix() %>%\n  unname()\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-27-1.png){fig-align='center' width=95%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nall(dog_and_side_by_day_f == dog_and_side_by_day)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n## Conclusion\n\nAlthough **formulae** works differently than **lme4**, and has different goals, we\nshowed that **formulae** produces the same design matrices as **lme4** for the variety\nof examples we covered. While case-based comparisons like these are not what one\nshould rely on when writing software, the examples here were really helpful when\nworking on the implementation in **formulae** and writing the corresponding tests.\nAnd if this post helps someone to better understand what's going on when\nworking with design matrices associated with group-specific effects, it will\nhave been even more worth it!",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}